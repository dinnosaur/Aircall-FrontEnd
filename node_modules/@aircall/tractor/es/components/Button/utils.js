import { css } from 'styled-components';
import { ButtonMode, ButtonVariant } from './Button.decl';
/**
 * Themes the button according to variant, disabled and the mode of the button.
 * Check this figma link for more details: https://www.figma.com/file/2D5oejKfR6yZJ3Qh6ZHgmu/(TEST)-00.-Tractor---Foundation
 */

export var makeButtonVariant = function makeButtonVariant(_ref) {
  var variant = _ref.variant,
      disabled = _ref.disabled,
      mode = _ref.mode,
      readOnly = _ref.readOnly,
      theme = _ref.theme;

  var getBackgroundColor = function getBackgroundColor(color) {
    return mode !== ButtonMode.FILL ? 'transparent' : color;
  };

  var getTextColor = function getTextColor(color, defaultTextColor) {
    return mode !== ButtonMode.FILL ? color : defaultTextColor;
  };

  var getBorderColor = function getBorderColor(color) {
    return mode === ButtonMode.LINK ? 'transparent' : color;
  };

  if (disabled) {
    return {
      // Fix issue when the disabled button is used inside of a Tooltip
      // the mouseEnter and mouseLeave events are not trigger sometimes
      // which makes the tooltip stay on the UI.
      // To "partially" resolve this React issue, we don't capture any events
      // when the button is disabled.
      // ref: https://github.com/facebook/react/issues/4251
      pointerEvents: 'none',
      backgroundColor: getBackgroundColor(theme.colors.grey.base),
      color: theme.colors.grey.dark,
      borderColor: getBorderColor(theme.colors.grey.base),
      cursor: 'not-allowed',
      svg: {
        fill: theme.colors.grey.dark
      }
    };
  }

  var makeButtonColor = function makeButtonColor(colorPalette, textColor) {
    return {
      backgroundColor: getBackgroundColor(colorPalette.base),
      color: getTextColor(colorPalette.base, textColor),
      borderColor: getBorderColor(colorPalette.base),
      svg: {
        fill: getTextColor(colorPalette.base, textColor)
      },
      ':hover': readOnly ? undefined : {
        backgroundColor: getBackgroundColor(colorPalette.dark),
        color: getTextColor(colorPalette.dark, textColor),
        borderColor: getBorderColor(colorPalette.dark),
        svg: {
          fill: getTextColor(colorPalette.dark, textColor)
        }
      },
      ':active': readOnly ? undefined : {
        backgroundColor: getBackgroundColor(colorPalette.darker),
        color: getTextColor(colorPalette.darker, textColor),
        borderColor: getBorderColor(colorPalette.darker),
        svg: {
          fill: getTextColor(colorPalette.darker, textColor)
        }
      },
      ':focus': readOnly ? undefined : {
        backgroundColor: getBackgroundColor(colorPalette.darker),
        color: getTextColor(colorPalette.darker, textColor),
        borderColor: getBorderColor(colorPalette.darker),
        svg: {
          fill: getTextColor(colorPalette.darker, textColor)
        }
      }
    };
  };

  var makeGhostButtonColor = function makeGhostButtonColor(colorPalette, textColor) {
    return {
      backgroundColor: colorPalette.base,
      color: textColor,
      svg: {
        fill: textColor
      },
      ':hover': readOnly ? undefined : {
        backgroundColor: colorPalette.light
      },
      ':active': readOnly ? undefined : {
        backgroundColor: colorPalette.lighter
      },
      ':focus': readOnly ? undefined : {
        backgroundColor: colorPalette.base,
        borderColor: textColor
      }
    };
  };

  var createNeutralColorPalette = function createNeutralColorPalette(color) {
    return {
      darker: color,
      dark: color,
      base: color,
      light: color,
      lighter: color
    };
  };

  var variants = {
    primary: {
      paletteColor: theme.colors.primary,
      textColor: theme.colors.base.white
    },
    destructive: {
      paletteColor: theme.colors.red,
      textColor: theme.colors.base.white
    },
    instructive: {
      paletteColor: theme.colors.blue,
      textColor: theme.colors.base.white
    },
    warning: {
      paletteColor: theme.colors.yellow,
      textColor: theme.colors.typography.textColor
    },
    ghost: {
      paletteColor: theme.colors.ghost,
      textColor: theme.colors.base.white
    },
    darkGhost: {
      paletteColor: theme.colors.darkGhost,
      textColor: theme.colors.grey.darker
    },
    black: {
      paletteColor: createNeutralColorPalette(theme.colors.text.base),
      textColor: theme.colors.text.lighter
    },
    white: {
      paletteColor: createNeutralColorPalette(theme.colors.text.lighter),
      textColor: theme.colors.text.base
    }
  };

  if (!variants[variant]) {
    return;
  }

  var _variants$variant = variants[variant],
      paletteColor = _variants$variant.paletteColor,
      textColor = _variants$variant.textColor;
  var buttonColorFn = variant === ButtonVariant.GHOST || variant === ButtonVariant.DARK_GHOST ? makeGhostButtonColor : makeButtonColor;
  return buttonColorFn(paletteColor, textColor);
};
export var makeButtonShadow = function makeButtonShadow(_ref2) {
  var disabled = _ref2.disabled,
      shadow = _ref2.shadow,
      theme = _ref2.theme;

  if (!shadow) {
    return;
  }

  if (disabled) {
    return css(["box-shadow:", ";"], theme.shadows[5]);
  }

  return css(["box-shadow:", ";:hover{box-shadow:", ";}:active{box-shadow:", ";}:focus{box-shadow:", ";}"], theme.shadows[5], theme.shadows[6], theme.shadows[1], theme.shadows[5]);
};
export var makeButtonTypography = function makeButtonTypography(_ref3) {
  var mode = _ref3.mode,
      disabled = _ref3.disabled,
      theme = _ref3.theme;

  if (mode === ButtonMode.LINK) {
    return css(["", " ", ""], theme.typography.variants.body, disabled ? undefined : css([":hover,:active,:focus{text-decoration:underline;}"]));
  }

  return css(["", ":hover,:active,:focus{text-decoration:none;}"], theme.typography.variants.subheading);
};
export var makeButtonSize = function makeButtonSize(_ref4) {
  var mode = _ref4.mode,
      buttonSize = _ref4.buttonSize,
      theme = _ref4.theme;

  if (mode === ButtonMode.LINK) {
    return theme.link.sizes[buttonSize];
  }

  return theme.button.sizes[buttonSize];
}; // Props that should not be forwarded to the HTML DOM elements

export var shouldForwardProp = function shouldForwardProp(prop) {
  return !['mode'].includes(prop);
};
import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import React from 'react';
import { renderHook, act } from '@testing-library/react-hooks';
import { ToastManager, toasts } from '..';
import { render, waitForElementToBeRemoved } from '../../../tests/test-utils';
import { useToast } from '../ToastContext';
describe('ToastManager', function () {
  beforeEach(function () {
    jest.useFakeTimers();
  });
  it('should show and and keep the toast forever', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var _renderHook, result, toast;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _renderHook = renderHook(function () {
              return useToast();
            }, {
              wrapper: ToastManager
            }), result = _renderHook.result;
            toast = {
              variant: 'instructive',
              message: 'message'
            };
            act(function () {
              result.current.showToast(toast);
            });
            expect(result.current.toasts.length).toBe(1);
            act(function () {
              jest.runAllTimers();
            });
            expect(result.current.toasts.length).toBe(1);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));
  it('should show and and keep the toast forever if the dismissIn is set to zero', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    var _renderHook2, result, toast;

    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _renderHook2 = renderHook(function () {
              return useToast();
            }, {
              wrapper: ToastManager
            }), result = _renderHook2.result;
            toast = {
              dismissIn: 0,
              variant: 'instructive',
              message: 'message'
            };
            act(function () {
              result.current.showToast(toast);
            });
            expect(result.current.toasts.length).toBe(1);
            act(function () {
              jest.runAllTimers();
            });
            expect(result.current.toasts.length).toBe(1);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  })));
  it('should show and remove a toast after a known delay', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
    var _renderHook3, result, toast;

    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _renderHook3 = renderHook(function () {
              return useToast();
            }, {
              wrapper: ToastManager
            }), result = _renderHook3.result;
            toast = {
              dismissIn: 3000,
              variant: 'instructive',
              message: 'message'
            };
            act(function () {
              result.current.showToast(toast);
            });
            expect(setTimeout).toHaveBeenCalledWith(expect.any(Function), toast.dismissIn);
            expect(result.current.toasts.length).toBe(1);
            act(function () {
              jest.advanceTimersByTime(toast.dismissIn);
            });
            expect(result.current.toasts.length).toBe(0);

          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })));
  it('should show and remove a toast when the cleanup function is called', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
    var _renderHook4, result, toast, cleanup;

    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _renderHook4 = renderHook(function () {
              return useToast();
            }, {
              wrapper: ToastManager
            }), result = _renderHook4.result;
            toast = {
              dismissIn: 3000,
              variant: 'instructive',
              message: 'message'
            };
            act(function () {
              cleanup = result.current.showToast(toast);
            });
            expect(result.current.toasts.length).toBe(1);
            act(function () {
              cleanup();
            });
            expect(result.current.toasts.length).toBe(0);

          case 6:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  })));
  it('should show a set of toasts and remove them one by one depending on the their delay', function () {
    var _renderHook5 = renderHook(function () {
      return useToast();
    }, {
      wrapper: ToastManager
    }),
        result = _renderHook5.result;

    var firstToast = {
      dismissIn: 3000,
      variant: 'instructive',
      message: 'message'
    };
    var secondToast = {
      dismissIn: 2000,
      variant: 'instructive',
      message: 'message'
    };
    var thirdToast = {
      dismissIn: 4000,
      variant: 'instructive',
      message: 'message'
    };
    act(function () {
      result.current.showToast(firstToast);
      result.current.showToast(secondToast);
      result.current.showToast(thirdToast);
    });
    expect(result.current.toasts.length).toBe(3);
    act(function () {
      jest.advanceTimersByTime(firstToast.dismissIn);
    }); // as firstToast dissmissIn is bigger that secontToast

    expect(result.current.toasts.length).toBe(1);
    act(function () {
      jest.advanceTimersByTime(thirdToast.dismissIn);
    });
    expect(result.current.toasts.length).toBe(0);
  });
  it('should not add a toast with the same ID twice', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
    var _renderHook6, result, toast;

    return _regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _renderHook6 = renderHook(function () {
              return useToast();
            }, {
              wrapper: ToastManager
            }), result = _renderHook6.result;
            toast = {
              id: 'random-id',
              dismissIn: 3000,
              variant: 'instructive',
              message: 'message'
            };
            act(function () {
              result.current.showToast(toast);
            });
            expect(setTimeout).toHaveBeenCalledWith(expect.any(Function), toast.dismissIn);
            expect(result.current.toasts.length).toBe(1);
            act(function () {
              jest.advanceTimersByTime(toast.dismissIn / 2);
              result.current.showToast(toast);
            });
            expect(result.current.toasts.length).toBe(1);
            act(function () {
              jest.advanceTimersByTime(toast.dismissIn / 2);
            });
            expect(result.current.toasts.length).toBe(0);

          case 9:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  })));
  it('should show toast message', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
    var _render, findByText, getByText;

    return _regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _render = render( /*#__PURE__*/React.createElement(React.Fragment, null)), findByText = _render.findByText, getByText = _render.getByText;
            toasts.showToast({
              variant: 'instructive',
              id: '1',
              message: 'message1',
              dismissIn: 100
            });
            _context6.next = 4;
            return findByText('message1');

          case 4:
            _context6.next = 6;
            return waitForElementToBeRemoved(getByText('message1'));

          case 6:
            toasts.showToast({
              variant: 'instructive',
              id: '2',
              message: 'message2',
              dismissIn: 100
            });
            _context6.next = 9;
            return findByText('message2');

          case 9:
            _context6.next = 11;
            return waitForElementToBeRemoved(getByText('message2'));

          case 11:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  })));
});
import React, { useCallback, useMemo, useState } from 'react';
import styled from 'styled-components';
import { color } from 'styled-system';
import { useTrigger } from '../../hooks/useTrigger';
import { BoundaryAlignment } from '../BoundaryAlignment';
import { Box } from '../Box';
import { Typography } from '../Typography';
import { getCaretOffset, makeCaretOffset } from './utils';
var TooltipContainer = styled(Box).withConfig({
  displayName: "Tooltip__TooltipContainer",
  componentId: "sc-8z4rfs-0"
})([":before{content:'';display:block;width:5px;height:5px;position:absolute;transform:translateX(-50%) translateY(-50%) rotate(45deg);", " ", "}"], color, makeCaretOffset);
export var Tooltip = function Tooltip(_ref) {
  var title = _ref.title,
      content = _ref.content,
      _ref$position = _ref.position,
      position = _ref$position === void 0 ? 'top' : _ref$position,
      _ref$anchor = _ref.anchor,
      anchor = _ref$anchor === void 0 ? 'center' : _ref$anchor,
      _ref$mouseEnterDelay = _ref.mouseEnterDelay,
      mouseEnterDelay = _ref$mouseEnterDelay === void 0 ? 0 : _ref$mouseEnterDelay,
      _ref$mouseLeaveDelay = _ref.mouseLeaveDelay,
      mouseLeaveDelay = _ref$mouseLeaveDelay === void 0 ? 100 : _ref$mouseLeaveDelay,
      _ref$maxWidth = _ref.maxWidth,
      maxWidth = _ref$maxWidth === void 0 ? '250px' : _ref$maxWidth,
      visible = _ref.visible,
      children = _ref.children,
      _ref$caretPointsAtCen = _ref.caretPointsAtCenter,
      caretPointsAtCenter = _ref$caretPointsAtCen === void 0 ? false : _ref$caretPointsAtCen,
      body = _ref.body,
      portalContainer = _ref.portalContainer;

  var _useState = useState(position),
      internalPosition = _useState[0],
      setInternalPosition = _useState[1];

  var _useState2 = useState(anchor),
      internalAnchor = _useState2[0],
      setInternalAnchor = _useState2[1];

  var child = React.Children.only(children);

  var _useTrigger = useTrigger(child, {
    trigger: 'hover',
    mouseEnterDelay: mouseEnterDelay,
    mouseLeaveDelay: mouseLeaveDelay,
    visible: visible,
    body: body,
    portalContainer: portalContainer
  }),
      trigger = _useTrigger[0],
      _useTrigger$ = _useTrigger[1],
      isVisible = _useTrigger$.isVisible,
      containerBoundingBox = _useTrigger$.containerBoundingBox,
      portal = _useTrigger$.portal,
      close = _useTrigger$.close,
      cancelClose = _useTrigger$.cancelClose;

  var handleComputePlacement = useCallback(function (placements) {
    // We need to make sure that the internal tooltip position is the same one defined on the Overlay.
    // So that we could react to placements changes and recompute the caret offsets.
    setInternalPosition(placements.position);
    setInternalAnchor(placements.anchor);
  }, []);
  var tooltipContent = useMemo(function () {
    return title ? /*#__PURE__*/React.createElement(Typography, {
      color: "text.lighter",
      variant: "body2",
      "data-test": "tooltip-title"
    }, title) : content;
  }, [title, content]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, trigger, isVisible && portal( /*#__PURE__*/React.createElement(BoundaryAlignment, {
    containerBoundingBox: containerBoundingBox,
    position: position,
    anchor: anchor,
    offset: getCaretOffset(position),
    onComputePlacement: handleComputePlacement,
    onMouseEnter: cancelClose,
    onMouseLeave: close
  }, /*#__PURE__*/React.createElement(TooltipContainer, {
    tooltipPosition: internalPosition,
    tooltipAnchor: internalAnchor,
    caretPointsAtCenter: caretPointsAtCenter,
    containerBoundingBox: containerBoundingBox,
    bg: "text.base",
    borderRadius: 8,
    p: 2,
    boxShadow: 1,
    maxWidth: maxWidth,
    "data-test": "tooltip-content"
  }, tooltipContent))));
};
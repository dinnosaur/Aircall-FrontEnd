import { SpacerDirection } from './Spacer.decl';
export var getMarginPropName = function getMarginPropName(_ref) {
  var direction = _ref.direction,
      reverse = _ref.reverse;
  return "m" + (direction === SpacerDirection.VERTICAL ? reverse ? 't' : 'b' : reverse ? 'l' : 'r');
};
export var getPaddingPropName = function getPaddingPropName(_ref2) {
  var reverse = _ref2.reverse;
  return "p" + (reverse ? 't' : 'b');
};
export var getChildStyle = function getChildStyle(_ref3) {
  var direction = _ref3.direction,
      reverse = _ref3.reverse,
      childIdx = _ref3.childIdx,
      childrenCount = _ref3.childrenCount,
      space = _ref3.space,
      wrapSpace = _ref3.wrapSpace,
      flexWrap = _ref3.flexWrap,
      itemsSized = _ref3.itemsSized;
  var boxProps = itemsSized === 'auto' ? {} : {
    flex: '1 1 0'
  };
  var marginProp = getMarginPropName({
    direction: direction,
    reverse: reverse
  });
  var paddingProp = getPaddingPropName({
    reverse: reverse
  });
  var isLastChild = childIdx === childrenCount - 1; // apply a margin only if the child is not the last one

  if (!isLastChild) {
    boxProps[marginProp] = space != null ? space : 'xxxs';
  } // Flex wrap only supports wrapping on multiple lines (and not multiple columns)


  if (flexWrap && direction === SpacerDirection.HORIZONTAL) {
    boxProps[paddingProp] = wrapSpace != null ? wrapSpace : 'xxxs';
  }

  return boxProps;
}; // Props that should not be forwarded to the HTML DOM elements

export var shouldForwardProp = function shouldForwardProp(prop, defaultValidationFn) {
  return !['direction'].includes(prop) && defaultValidationFn(prop);
};
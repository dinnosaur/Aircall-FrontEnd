import React, { useCallback, useLayoutEffect, useRef, useState } from 'react';
import { getBoundingClientRect } from '../../utils/dom';
import { Box } from '../Box';
import { OPPOSITE_POSITION, OPPOSITE_ANCHOR } from './constants';
import { computePlacement, hasOverflowedHorizontally, hasOverflowedVertically } from './utils';
/**
 * BoundaryAlignment simply renders its children, which represent
 * the main content.
 *
 * The overlay sets the positionning and basic styling.
 */

export var BoundaryAlignment = function BoundaryAlignment(_ref) {
  var containerBoundingBox = _ref.containerBoundingBox,
      fluid = _ref.fluid,
      _ref$position = _ref.position,
      position = _ref$position === void 0 ? 'bottom' : _ref$position,
      _ref$anchor = _ref.anchor,
      anchor = _ref$anchor === void 0 ? 'start' : _ref$anchor,
      _ref$boundaryElement = _ref.boundaryElement,
      boundaryElement = _ref$boundaryElement === void 0 ? window : _ref$boundaryElement,
      onComputePlacement = _ref.onComputePlacement,
      offset = _ref.offset,
      onClick = _ref.onClick,
      onMouseEnter = _ref.onMouseEnter,
      onMouseLeave = _ref.onMouseLeave,
      children = _ref.children;
  var overlayRef = useRef(null);

  var _useState = useState(),
      positionState = _useState[0],
      setPositionState = _useState[1];

  var _useState2 = useState({
    width: 0,
    height: 0
  }),
      childrenDimensions = _useState2[0],
      setChildrenDimensions = _useState2[1];

  var getOverlayDimensions = useCallback(function () {
    var _getBoundingClientRec = getBoundingClientRect(overlayRef.current),
        width = _getBoundingClientRec.width,
        height = _getBoundingClientRec.height;

    return {
      width: width,
      height: height
    };
  }, []);
  var computeOverlayStyle = useCallback(function () {
    // Don't show the element until its position is being calculated.
    if (!positionState) {
      return {
        opacity: 0
      };
    }

    var top = positionState.top,
        left = positionState.left; // Set overlay width to container's width

    var width = fluid ? containerBoundingBox.width : undefined;
    return {
      top: top,
      left: left,
      width: width
    };
  }, [positionState, containerBoundingBox, fluid]);
  var getOverlayPlacement = useCallback(function () {
    var _getOverlayDimensions = getOverlayDimensions(),
        width = _getOverlayDimensions.width,
        height = _getOverlayDimensions.height; // By default we set the position overlay to the bottom/left
    // and then we compute its placement depending on the props provided by the parent


    return computePlacement({
      top: containerBoundingBox.bottom,
      left: containerBoundingBox.left,
      width: width,
      height: height
    }, {
      position: position,
      anchor: anchor,
      initialPosition: position,
      initialAnchor: anchor,
      containerBoundingBox: containerBoundingBox
    });
  }, [getOverlayDimensions, containerBoundingBox, position, anchor]);
  var computeOverlayPlacement = useCallback(function () {
    var initialPlacement = getOverlayPlacement();
    var oppositePosition = OPPOSITE_POSITION[position];
    var oppositeAnchor = OPPOSITE_ANCHOR[anchor];
    var nextPosition = position;
    var nextAnchor = anchor;

    if (hasOverflowedHorizontally(initialPlacement, boundaryElement)) {
      if (nextPosition === 'left' || nextPosition === 'right') {
        nextPosition = oppositePosition;
      } else if (nextAnchor === 'start' || nextAnchor === 'end') {
        nextAnchor = oppositeAnchor;
      }
    }

    if (hasOverflowedVertically(initialPlacement, boundaryElement)) {
      if (nextPosition === 'top' || nextPosition === 'bottom') {
        nextPosition = oppositePosition;
      } else if (nextAnchor === 'start' || nextAnchor === 'end') {
        nextAnchor = oppositeAnchor;
      }
    } // Compute the new placement depending on the new position and direction


    var _computePlacement = computePlacement(initialPlacement, {
      initialPosition: position,
      position: nextPosition,
      initialAnchor: anchor,
      anchor: nextAnchor,
      containerBoundingBox: containerBoundingBox,
      offset: offset
    }),
        top = _computePlacement.top,
        left = _computePlacement.left;

    onComputePlacement == null ? void 0 : onComputePlacement({
      position: nextPosition,
      anchor: nextAnchor
    });
    setPositionState({
      top: top,
      left: left
    });
  }, [getOverlayPlacement, containerBoundingBox, position, anchor, onComputePlacement, offset, boundaryElement]);
  useLayoutEffect(function () {
    computeOverlayPlacement();
  }, [computeOverlayPlacement]);
  useLayoutEffect(function () {
    var _getOverlayDimensions2 = getOverlayDimensions(),
        width = _getOverlayDimensions2.width,
        height = _getOverlayDimensions2.height;

    var isWidthEqual = width === childrenDimensions.width;
    var isHeightEqual = height === childrenDimensions.height; // Recompute the placement of the overlay if the children's width or height has changed

    if (!isHeightEqual || !isWidthEqual) {
      setChildrenDimensions({
        width: width,
        height: height
      });
      computeOverlayPlacement();
    }
  }, [getOverlayDimensions, childrenDimensions, computeOverlayPlacement]);
  return /*#__PURE__*/React.createElement(Box, {
    "data-test": "boundary-alignment",
    position: "fixed",
    zIndex: 1010,
    onClick: onClick,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    style: computeOverlayStyle(),
    ref: overlayRef
  }, children);
};
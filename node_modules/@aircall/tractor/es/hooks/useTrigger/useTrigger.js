import _extends from "@babel/runtime/helpers/esm/extends";
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { debounce } from 'lodash-es';
import { createPortal } from 'react-dom';
import { useCloseOnClick } from '../useCloseOnClick';
import { useCloseOnResize } from '../useCloseOnResize';
import { useCloseOnScroll } from '../useCloseOnScroll';
import { useCreateNode } from '../useCreateNode';
export var useTrigger = function useTrigger(element, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$trigger = _options.trigger,
      trigger = _options$trigger === void 0 ? 'hover' : _options$trigger,
      _options$closeOnInsid = _options.closeOnInsideClick,
      closeOnInsideClick = _options$closeOnInsid === void 0 ? false : _options$closeOnInsid,
      _options$portalContai = _options.portalContainer,
      portalContainer = _options$portalContai === void 0 ? document.body : _options$portalContai,
      _options$body = _options.body,
      body = _options$body === void 0 ? document.body : _options$body,
      _options$mouseEnterDe = _options.mouseEnterDelay,
      mouseEnterDelay = _options$mouseEnterDe === void 0 ? 0 : _options$mouseEnterDe,
      _options$mouseLeaveDe = _options.mouseLeaveDelay,
      mouseLeaveDelay = _options$mouseLeaveDe === void 0 ? 100 : _options$mouseLeaveDe,
      visible = _options.visible,
      onVisibilityChange = _options.onVisibilityChange;
  var triggerRef = useRef(null);
  var portalRef = useRef(null);

  var _useState = useState(visible != null ? visible : false),
      internalVisibility = _useState[0],
      setInternalVisibility = _useState[1];

  var portalNode = useCreateNode(portalContainer, !internalVisibility);

  var _useState2 = useState({
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    width: 0,
    height: 0
  }),
      containerBoundingBox = _useState2[0],
      setContainerBoundingBox = _useState2[1];

  var computeBoundingBox = useCallback(function () {
    var containerRef = triggerRef.current;

    if (containerRef) {
      setContainerBoundingBox(containerRef.getBoundingClientRect());
    }
  }, []);
  var handleOpen = useCallback(function () {
    // Don't do anything if the overlay is already open
    if (internalVisibility) {
      return;
    }

    setInternalVisibility(true);
  }, [internalVisibility]);
  var handleClose = useCallback(function () {
    // Don't do anything if the overlay is already closed
    if (!internalVisibility) {
      return;
    }

    setInternalVisibility(false);
  }, [internalVisibility]);
  var handleToggle = useCallback(function () {
    var willBeOpen = !internalVisibility;

    if (willBeOpen) {
      handleOpen();
    } else {
      handleClose();
    }
  }, [internalVisibility, handleOpen, handleClose]); // Provide a portal component so that we can grab its reference
  // to check if overlay needs to be closed if the user clicks outside of it.

  var wrapWithPortal = useCallback(function (children) {
    if (!portalNode) {
      return null;
    }

    portalRef.current = /*#__PURE__*/createPortal(children, portalNode);
    return portalRef.current;
  }, [portalNode]);
  useEffect(function () {
    computeBoundingBox();
  }, [internalVisibility, visible, computeBoundingBox]);
  useEffect(function () {
    if (typeof visible !== 'undefined') {
      setInternalVisibility(visible);
    }
  }, [visible]);
  useEffect(function () {
    onVisibilityChange == null ? void 0 : onVisibilityChange(internalVisibility);
  }, [internalVisibility, onVisibilityChange]);
  var fireEvent = useCallback(function (type, event) {
    var _element$props$type, _element$props;

    (_element$props$type = (_element$props = element.props)[type]) == null ? void 0 : _element$props$type.call(_element$props, event);
  }, [element]);
  var onMouseEnter = useMemo(function () {
    return debounce(function (event) {
      fireEvent('onMouseEnter', event);
      handleOpen();
    }, mouseEnterDelay);
  }, [handleOpen, mouseEnterDelay, fireEvent]);
  var onMouseLeave = useMemo(function () {
    return debounce(function (event) {
      fireEvent('onMouseLeave', event); // Cancel the mouseEnter if it's enter event is delayed

      onMouseEnter.cancel();
      handleClose();
    }, mouseLeaveDelay);
  }, [handleClose, mouseLeaveDelay, fireEvent, onMouseEnter]);
  var onClick = useCallback(function (event) {
    fireEvent('onClick', event);
    handleToggle();
  }, [handleToggle, fireEvent]);
  useCloseOnScroll({
    container: body,
    node: portalNode,
    onClose: handleClose
  });
  useCloseOnClick({
    container: body,
    triggerNode: triggerRef.current,
    node: portalNode,
    closeOnInsideClick: closeOnInsideClick,
    onClose: handleClose
  });
  useCloseOnResize({
    node: portalNode,
    onClose: handleClose
  });
  var eventProps = useMemo(function () {
    switch (trigger) {
      case 'click':
        return {
          onClick: onClick
        };

      case 'hover':
        return {
          onMouseEnter: onMouseEnter,
          onMouseLeave: onMouseLeave
        };

      default:
        return {};
    }
  }, [trigger, onMouseEnter, onMouseLeave, onClick]);
  var el = /*#__PURE__*/React.cloneElement(element, _extends({
    key: 'element-trigger',
    ref: triggerRef
  }, eventProps));
  var props = {
    isVisible: internalVisibility,
    containerBoundingBox: containerBoundingBox,
    close: handleClose,
    cancelClose: onMouseLeave.cancel,
    portal: wrapWithPortal
  };
  return [el, props];
};
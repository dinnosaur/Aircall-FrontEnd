"use strict";

var _react = _interopRequireDefault(require("react"));

var _reactHooks = require("@testing-library/react-hooks");

var _ = require("..");

var _testUtils = require("../../../tests/test-utils");

var _ToastContext = require("../ToastContext");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

describe('ToastManager', function () {
  beforeEach(function () {
    jest.useFakeTimers();
  });
  it('should show and and keep the toast forever', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var _renderHook, result, toast;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _renderHook = (0, _reactHooks.renderHook)(function () {
              return (0, _ToastContext.useToast)();
            }, {
              wrapper: _.ToastManager
            }), result = _renderHook.result;
            toast = {
              variant: 'instructive',
              message: 'message'
            };
            (0, _reactHooks.act)(function () {
              result.current.showToast(toast);
            });
            expect(result.current.toasts.length).toBe(1);
            (0, _reactHooks.act)(function () {
              jest.runAllTimers();
            });
            expect(result.current.toasts.length).toBe(1);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));
  it('should show and and keep the toast forever if the dismissIn is set to zero', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
    var _renderHook2, result, toast;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _renderHook2 = (0, _reactHooks.renderHook)(function () {
              return (0, _ToastContext.useToast)();
            }, {
              wrapper: _.ToastManager
            }), result = _renderHook2.result;
            toast = {
              dismissIn: 0,
              variant: 'instructive',
              message: 'message'
            };
            (0, _reactHooks.act)(function () {
              result.current.showToast(toast);
            });
            expect(result.current.toasts.length).toBe(1);
            (0, _reactHooks.act)(function () {
              jest.runAllTimers();
            });
            expect(result.current.toasts.length).toBe(1);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  })));
  it('should show and remove a toast after a known delay', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
    var _renderHook3, result, toast;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _renderHook3 = (0, _reactHooks.renderHook)(function () {
              return (0, _ToastContext.useToast)();
            }, {
              wrapper: _.ToastManager
            }), result = _renderHook3.result;
            toast = {
              dismissIn: 3000,
              variant: 'instructive',
              message: 'message'
            };
            (0, _reactHooks.act)(function () {
              result.current.showToast(toast);
            });
            expect(setTimeout).toHaveBeenCalledWith(expect.any(Function), toast.dismissIn);
            expect(result.current.toasts.length).toBe(1);
            (0, _reactHooks.act)(function () {
              jest.advanceTimersByTime(toast.dismissIn);
            });
            expect(result.current.toasts.length).toBe(0);

          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  })));
  it('should show and remove a toast when the cleanup function is called', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
    var _renderHook4, result, toast, cleanup;

    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _renderHook4 = (0, _reactHooks.renderHook)(function () {
              return (0, _ToastContext.useToast)();
            }, {
              wrapper: _.ToastManager
            }), result = _renderHook4.result;
            toast = {
              dismissIn: 3000,
              variant: 'instructive',
              message: 'message'
            };
            (0, _reactHooks.act)(function () {
              cleanup = result.current.showToast(toast);
            });
            expect(result.current.toasts.length).toBe(1);
            (0, _reactHooks.act)(function () {
              cleanup();
            });
            expect(result.current.toasts.length).toBe(0);

          case 6:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  })));
  it('should show a set of toasts and remove them one by one depending on the their delay', function () {
    var _renderHook5 = (0, _reactHooks.renderHook)(function () {
      return (0, _ToastContext.useToast)();
    }, {
      wrapper: _.ToastManager
    }),
        result = _renderHook5.result;

    var firstToast = {
      dismissIn: 3000,
      variant: 'instructive',
      message: 'message'
    };
    var secondToast = {
      dismissIn: 2000,
      variant: 'instructive',
      message: 'message'
    };
    var thirdToast = {
      dismissIn: 4000,
      variant: 'instructive',
      message: 'message'
    };
    (0, _reactHooks.act)(function () {
      result.current.showToast(firstToast);
      result.current.showToast(secondToast);
      result.current.showToast(thirdToast);
    });
    expect(result.current.toasts.length).toBe(3);
    (0, _reactHooks.act)(function () {
      jest.advanceTimersByTime(firstToast.dismissIn);
    }); // as firstToast dissmissIn is bigger that secontToast

    expect(result.current.toasts.length).toBe(1);
    (0, _reactHooks.act)(function () {
      jest.advanceTimersByTime(thirdToast.dismissIn);
    });
    expect(result.current.toasts.length).toBe(0);
  });
  it('should not add a toast with the same ID twice', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
    var _renderHook6, result, toast;

    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _renderHook6 = (0, _reactHooks.renderHook)(function () {
              return (0, _ToastContext.useToast)();
            }, {
              wrapper: _.ToastManager
            }), result = _renderHook6.result;
            toast = {
              id: 'random-id',
              dismissIn: 3000,
              variant: 'instructive',
              message: 'message'
            };
            (0, _reactHooks.act)(function () {
              result.current.showToast(toast);
            });
            expect(setTimeout).toHaveBeenCalledWith(expect.any(Function), toast.dismissIn);
            expect(result.current.toasts.length).toBe(1);
            (0, _reactHooks.act)(function () {
              jest.advanceTimersByTime(toast.dismissIn / 2);
              result.current.showToast(toast);
            });
            expect(result.current.toasts.length).toBe(1);
            (0, _reactHooks.act)(function () {
              jest.advanceTimersByTime(toast.dismissIn / 2);
            });
            expect(result.current.toasts.length).toBe(0);

          case 9:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  })));
  it('should show toast message', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
    var _render, findByText, getByText;

    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _render = (0, _testUtils.render)( /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null)), findByText = _render.findByText, getByText = _render.getByText;

            _.toasts.showToast({
              variant: 'instructive',
              id: '1',
              message: 'message1',
              dismissIn: 100
            });

            _context6.next = 4;
            return findByText('message1');

          case 4:
            _context6.next = 6;
            return (0, _testUtils.waitForElementToBeRemoved)(getByText('message1'));

          case 6:
            _.toasts.showToast({
              variant: 'instructive',
              id: '2',
              message: 'message2',
              dismissIn: 100
            });

            _context6.next = 9;
            return findByText('message2');

          case 9:
            _context6.next = 11;
            return (0, _testUtils.waitForElementToBeRemoved)(getByText('message2'));

          case 11:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  })));
});
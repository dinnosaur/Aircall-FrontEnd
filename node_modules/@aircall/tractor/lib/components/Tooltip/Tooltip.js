"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tooltip = void 0;

var _react = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _styledSystem = require("styled-system");

var _useTrigger2 = require("../../hooks/useTrigger");

var _BoundaryAlignment = require("../BoundaryAlignment");

var _Box = require("../Box");

var _Typography = require("../Typography");

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var TooltipContainer = (0, _styledComponents["default"])(_Box.Box).withConfig({
  displayName: "Tooltip__TooltipContainer",
  componentId: "sc-8z4rfs-0"
})([":before{content:'';display:block;width:5px;height:5px;position:absolute;transform:translateX(-50%) translateY(-50%) rotate(45deg);", " ", "}"], _styledSystem.color, _utils.makeCaretOffset);

var Tooltip = function Tooltip(_ref) {
  var title = _ref.title,
      content = _ref.content,
      _ref$position = _ref.position,
      position = _ref$position === void 0 ? 'top' : _ref$position,
      _ref$anchor = _ref.anchor,
      anchor = _ref$anchor === void 0 ? 'center' : _ref$anchor,
      _ref$mouseEnterDelay = _ref.mouseEnterDelay,
      mouseEnterDelay = _ref$mouseEnterDelay === void 0 ? 0 : _ref$mouseEnterDelay,
      _ref$mouseLeaveDelay = _ref.mouseLeaveDelay,
      mouseLeaveDelay = _ref$mouseLeaveDelay === void 0 ? 100 : _ref$mouseLeaveDelay,
      _ref$maxWidth = _ref.maxWidth,
      maxWidth = _ref$maxWidth === void 0 ? '250px' : _ref$maxWidth,
      visible = _ref.visible,
      children = _ref.children,
      _ref$caretPointsAtCen = _ref.caretPointsAtCenter,
      caretPointsAtCenter = _ref$caretPointsAtCen === void 0 ? false : _ref$caretPointsAtCen,
      body = _ref.body,
      portalContainer = _ref.portalContainer;

  var _useState = (0, _react.useState)(position),
      internalPosition = _useState[0],
      setInternalPosition = _useState[1];

  var _useState2 = (0, _react.useState)(anchor),
      internalAnchor = _useState2[0],
      setInternalAnchor = _useState2[1];

  var child = _react["default"].Children.only(children);

  var _useTrigger = (0, _useTrigger2.useTrigger)(child, {
    trigger: 'hover',
    mouseEnterDelay: mouseEnterDelay,
    mouseLeaveDelay: mouseLeaveDelay,
    visible: visible,
    body: body,
    portalContainer: portalContainer
  }),
      trigger = _useTrigger[0],
      _useTrigger$ = _useTrigger[1],
      isVisible = _useTrigger$.isVisible,
      containerBoundingBox = _useTrigger$.containerBoundingBox,
      portal = _useTrigger$.portal,
      close = _useTrigger$.close,
      cancelClose = _useTrigger$.cancelClose;

  var handleComputePlacement = (0, _react.useCallback)(function (placements) {
    // We need to make sure that the internal tooltip position is the same one defined on the Overlay.
    // So that we could react to placements changes and recompute the caret offsets.
    setInternalPosition(placements.position);
    setInternalAnchor(placements.anchor);
  }, []);
  var tooltipContent = (0, _react.useMemo)(function () {
    return title ? /*#__PURE__*/_react["default"].createElement(_Typography.Typography, {
      color: "text.lighter",
      variant: "body2",
      "data-test": "tooltip-title"
    }, title) : content;
  }, [title, content]);
  return /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, trigger, isVisible && portal( /*#__PURE__*/_react["default"].createElement(_BoundaryAlignment.BoundaryAlignment, {
    containerBoundingBox: containerBoundingBox,
    position: position,
    anchor: anchor,
    offset: (0, _utils.getCaretOffset)(position),
    onComputePlacement: handleComputePlacement,
    onMouseEnter: cancelClose,
    onMouseLeave: close
  }, /*#__PURE__*/_react["default"].createElement(TooltipContainer, {
    tooltipPosition: internalPosition,
    tooltipAnchor: internalAnchor,
    caretPointsAtCenter: caretPointsAtCenter,
    containerBoundingBox: containerBoundingBox,
    bg: "text.base",
    borderRadius: 8,
    p: 2,
    boxShadow: 1,
    maxWidth: maxWidth,
    "data-test": "tooltip-content"
  }, tooltipContent))));
};

exports.Tooltip = Tooltip;
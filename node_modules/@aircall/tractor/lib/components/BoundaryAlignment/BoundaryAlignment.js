"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoundaryAlignment = void 0;

var _react = _interopRequireWildcard(require("react"));

var _dom = require("../../utils/dom");

var _Box = require("../Box");

var _constants = require("./constants");

var _utils = require("./utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * BoundaryAlignment simply renders its children, which represent
 * the main content.
 *
 * The overlay sets the positionning and basic styling.
 */
var BoundaryAlignment = function BoundaryAlignment(_ref) {
  var containerBoundingBox = _ref.containerBoundingBox,
      fluid = _ref.fluid,
      _ref$position = _ref.position,
      position = _ref$position === void 0 ? 'bottom' : _ref$position,
      _ref$anchor = _ref.anchor,
      anchor = _ref$anchor === void 0 ? 'start' : _ref$anchor,
      _ref$boundaryElement = _ref.boundaryElement,
      boundaryElement = _ref$boundaryElement === void 0 ? window : _ref$boundaryElement,
      onComputePlacement = _ref.onComputePlacement,
      offset = _ref.offset,
      onClick = _ref.onClick,
      onMouseEnter = _ref.onMouseEnter,
      onMouseLeave = _ref.onMouseLeave,
      children = _ref.children;
  var overlayRef = (0, _react.useRef)(null);

  var _useState = (0, _react.useState)(),
      positionState = _useState[0],
      setPositionState = _useState[1];

  var _useState2 = (0, _react.useState)({
    width: 0,
    height: 0
  }),
      childrenDimensions = _useState2[0],
      setChildrenDimensions = _useState2[1];

  var getOverlayDimensions = (0, _react.useCallback)(function () {
    var _getBoundingClientRec = (0, _dom.getBoundingClientRect)(overlayRef.current),
        width = _getBoundingClientRec.width,
        height = _getBoundingClientRec.height;

    return {
      width: width,
      height: height
    };
  }, []);
  var computeOverlayStyle = (0, _react.useCallback)(function () {
    // Don't show the element until its position is being calculated.
    if (!positionState) {
      return {
        opacity: 0
      };
    }

    var top = positionState.top,
        left = positionState.left; // Set overlay width to container's width

    var width = fluid ? containerBoundingBox.width : undefined;
    return {
      top: top,
      left: left,
      width: width
    };
  }, [positionState, containerBoundingBox, fluid]);
  var getOverlayPlacement = (0, _react.useCallback)(function () {
    var _getOverlayDimensions = getOverlayDimensions(),
        width = _getOverlayDimensions.width,
        height = _getOverlayDimensions.height; // By default we set the position overlay to the bottom/left
    // and then we compute its placement depending on the props provided by the parent


    return (0, _utils.computePlacement)({
      top: containerBoundingBox.bottom,
      left: containerBoundingBox.left,
      width: width,
      height: height
    }, {
      position: position,
      anchor: anchor,
      initialPosition: position,
      initialAnchor: anchor,
      containerBoundingBox: containerBoundingBox
    });
  }, [getOverlayDimensions, containerBoundingBox, position, anchor]);
  var computeOverlayPlacement = (0, _react.useCallback)(function () {
    var initialPlacement = getOverlayPlacement();
    var oppositePosition = _constants.OPPOSITE_POSITION[position];
    var oppositeAnchor = _constants.OPPOSITE_ANCHOR[anchor];
    var nextPosition = position;
    var nextAnchor = anchor;

    if ((0, _utils.hasOverflowedHorizontally)(initialPlacement, boundaryElement)) {
      if (nextPosition === 'left' || nextPosition === 'right') {
        nextPosition = oppositePosition;
      } else if (nextAnchor === 'start' || nextAnchor === 'end') {
        nextAnchor = oppositeAnchor;
      }
    }

    if ((0, _utils.hasOverflowedVertically)(initialPlacement, boundaryElement)) {
      if (nextPosition === 'top' || nextPosition === 'bottom') {
        nextPosition = oppositePosition;
      } else if (nextAnchor === 'start' || nextAnchor === 'end') {
        nextAnchor = oppositeAnchor;
      }
    } // Compute the new placement depending on the new position and direction


    var _computePlacement = (0, _utils.computePlacement)(initialPlacement, {
      initialPosition: position,
      position: nextPosition,
      initialAnchor: anchor,
      anchor: nextAnchor,
      containerBoundingBox: containerBoundingBox,
      offset: offset
    }),
        top = _computePlacement.top,
        left = _computePlacement.left;

    onComputePlacement == null ? void 0 : onComputePlacement({
      position: nextPosition,
      anchor: nextAnchor
    });
    setPositionState({
      top: top,
      left: left
    });
  }, [getOverlayPlacement, containerBoundingBox, position, anchor, onComputePlacement, offset, boundaryElement]);
  (0, _react.useLayoutEffect)(function () {
    computeOverlayPlacement();
  }, [computeOverlayPlacement]);
  (0, _react.useLayoutEffect)(function () {
    var _getOverlayDimensions2 = getOverlayDimensions(),
        width = _getOverlayDimensions2.width,
        height = _getOverlayDimensions2.height;

    var isWidthEqual = width === childrenDimensions.width;
    var isHeightEqual = height === childrenDimensions.height; // Recompute the placement of the overlay if the children's width or height has changed

    if (!isHeightEqual || !isWidthEqual) {
      setChildrenDimensions({
        width: width,
        height: height
      });
      computeOverlayPlacement();
    }
  }, [getOverlayDimensions, childrenDimensions, computeOverlayPlacement]);
  return /*#__PURE__*/_react["default"].createElement(_Box.Box, {
    "data-test": "boundary-alignment",
    position: "fixed",
    zIndex: 1010,
    onClick: onClick,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    style: computeOverlayStyle(),
    ref: overlayRef
  }, children);
};

exports.BoundaryAlignment = BoundaryAlignment;
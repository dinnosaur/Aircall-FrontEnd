"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getElementBoundaries = exports.computeTop = exports.computePlacement = exports.computeLeft = exports.adjustPlacement = void 0;
exports.hasOverflowedHorizontally = hasOverflowedHorizontally;
exports.hasOverflowedVertically = hasOverflowedVertically;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/**
 * It computes the top position of the BoundaryAlignment based on the BoundaryAlignment and parent dimensions
 */
var computeTop = function computeTop(_ref) {
  var position = _ref.position,
      anchor = _ref.anchor,
      overlayDimensions = _ref.overlayDimensions,
      containerBoundingBox = _ref.containerBoundingBox;

  if (position === 'top') {
    return containerBoundingBox.top - overlayDimensions.height;
  }

  if (position === 'bottom') {
    return containerBoundingBox.bottom;
  }

  if (position === 'right' || position === 'left') {
    if (anchor === 'end') {
      return containerBoundingBox.bottom - overlayDimensions.height;
    }

    if (anchor === 'start') {
      return containerBoundingBox.top;
    }

    if (anchor === 'center') {
      return containerBoundingBox.top + containerBoundingBox.height / 2 - overlayDimensions.height / 2;
    }
  }

  return 0;
};
/**
 * It computes the left position of the BoundaryAlignment based on the BoundaryAlignment and parent dimensions
 */


exports.computeTop = computeTop;

var computeLeft = function computeLeft(_ref2) {
  var position = _ref2.position,
      anchor = _ref2.anchor,
      overlayDimensions = _ref2.overlayDimensions,
      containerBoundingBox = _ref2.containerBoundingBox;

  if (position === 'right') {
    return containerBoundingBox.right;
  }

  if (position === 'left') {
    return containerBoundingBox.left - overlayDimensions.width;
  }

  if (position === 'top' || position === 'bottom') {
    if (anchor === 'center') {
      return containerBoundingBox.left - overlayDimensions.width / 2 + containerBoundingBox.width / 2;
    }

    if (anchor === 'start') {
      return containerBoundingBox.left;
    }

    if (anchor === 'end') {
      return containerBoundingBox.right - overlayDimensions.width;
    }
  }

  return 0;
};
/**
 * Add extra offset to the BoundaryAlignment if provided
 */


exports.computeLeft = computeLeft;

var adjustPlacement = function adjustPlacement(placement, props) {
  var _offset$top, _offset$left;

  var initialPosition = props.initialPosition,
      position = props.position,
      initialAnchor = props.initialAnchor,
      anchor = props.anchor,
      offset = props.offset;
  var topOffset = (_offset$top = offset == null ? void 0 : offset.top) != null ? _offset$top : 0;
  var leftOffset = (_offset$left = offset == null ? void 0 : offset.left) != null ? _offset$left : 0;
  var hasPositionChanged = initialPosition !== position;
  var hasAnchorChanged = initialAnchor !== anchor; // coefficient determines if we need to subtract or add the offset to the top/left positions

  var topCoefficient = hasPositionChanged && ['top', 'bottom'].includes(position) || hasAnchorChanged && ['start', 'end'].includes(anchor) ? -1 : 1;
  var leftCoefficient = hasPositionChanged && ['left', 'right'].includes(position) || hasAnchorChanged && ['start', 'end'].includes(anchor) ? -1 : 1;
  return _extends({}, placement, {
    top: placement.top + topCoefficient * topOffset,
    left: placement.left + leftCoefficient * leftOffset
  });
};

exports.adjustPlacement = adjustPlacement;

var getElementBoundaries = function getElementBoundaries(boundaryElement) {
  if (boundaryElement instanceof HTMLElement) {
    var _boundaryElement$getB = boundaryElement.getBoundingClientRect(),
        right = _boundaryElement$getB.right,
        bottom = _boundaryElement$getB.bottom,
        top = _boundaryElement$getB.top,
        left = _boundaryElement$getB.left;

    return {
      rightBoundary: right,
      bottomBoundary: bottom,
      topBoundary: top,
      leftBoundary: left
    };
  }

  return {
    rightBoundary: boundaryElement.innerWidth,
    bottomBoundary: boundaryElement.innerHeight,
    topBoundary: 0,
    leftBoundary: 0
  };
};
/**
 * Checks if the BoundaryAlignment is popping out horizontally of the parent container
 */


exports.getElementBoundaries = getElementBoundaries;

function hasOverflowedHorizontally(placement, boundaryElement) {
  var _getElementBoundaries = getElementBoundaries(boundaryElement),
      rightBoundary = _getElementBoundaries.rightBoundary,
      leftBoundary = _getElementBoundaries.leftBoundary;

  return placement.left + placement.width > rightBoundary || placement.left < leftBoundary;
}
/**
 * Checks if the BoundaryAlignment is popping out vertically of the parent container
 */


function hasOverflowedVertically(placement, boundaryElement) {
  var _getElementBoundaries2 = getElementBoundaries(boundaryElement),
      bottomBoundary = _getElementBoundaries2.bottomBoundary,
      topBoundary = _getElementBoundaries2.topBoundary;

  return placement.top + placement.height > bottomBoundary || placement.top < topBoundary;
}

var computePlacement = function computePlacement(overlayDimensions, props) {
  var containerBoundingBox = props.containerBoundingBox;
  var top = computeTop({
    position: props.position,
    anchor: props.anchor,
    overlayDimensions: overlayDimensions,
    containerBoundingBox: containerBoundingBox
  });
  var left = computeLeft({
    position: props.position,
    anchor: props.anchor,
    overlayDimensions: overlayDimensions,
    containerBoundingBox: containerBoundingBox
  });
  return adjustPlacement({
    left: left,
    top: top,
    width: overlayDimensions.width,
    height: overlayDimensions.height
  }, props);
};

exports.computePlacement = computePlacement;
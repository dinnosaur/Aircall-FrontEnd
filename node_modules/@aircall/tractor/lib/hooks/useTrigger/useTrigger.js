"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTrigger = void 0;

var _react = _interopRequireWildcard(require("react"));

var _lodashEs = require("lodash-es");

var _reactDom = require("react-dom");

var _useCloseOnClick = require("../useCloseOnClick");

var _useCloseOnResize = require("../useCloseOnResize");

var _useCloseOnScroll = require("../useCloseOnScroll");

var _useCreateNode = require("../useCreateNode");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var useTrigger = function useTrigger(element, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$trigger = _options.trigger,
      trigger = _options$trigger === void 0 ? 'hover' : _options$trigger,
      _options$closeOnInsid = _options.closeOnInsideClick,
      closeOnInsideClick = _options$closeOnInsid === void 0 ? false : _options$closeOnInsid,
      _options$portalContai = _options.portalContainer,
      portalContainer = _options$portalContai === void 0 ? document.body : _options$portalContai,
      _options$body = _options.body,
      body = _options$body === void 0 ? document.body : _options$body,
      _options$mouseEnterDe = _options.mouseEnterDelay,
      mouseEnterDelay = _options$mouseEnterDe === void 0 ? 0 : _options$mouseEnterDe,
      _options$mouseLeaveDe = _options.mouseLeaveDelay,
      mouseLeaveDelay = _options$mouseLeaveDe === void 0 ? 100 : _options$mouseLeaveDe,
      visible = _options.visible,
      onVisibilityChange = _options.onVisibilityChange;
  var triggerRef = (0, _react.useRef)(null);
  var portalRef = (0, _react.useRef)(null);

  var _useState = (0, _react.useState)(visible != null ? visible : false),
      internalVisibility = _useState[0],
      setInternalVisibility = _useState[1];

  var portalNode = (0, _useCreateNode.useCreateNode)(portalContainer, !internalVisibility);

  var _useState2 = (0, _react.useState)({
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    width: 0,
    height: 0
  }),
      containerBoundingBox = _useState2[0],
      setContainerBoundingBox = _useState2[1];

  var computeBoundingBox = (0, _react.useCallback)(function () {
    var containerRef = triggerRef.current;

    if (containerRef) {
      setContainerBoundingBox(containerRef.getBoundingClientRect());
    }
  }, []);
  var handleOpen = (0, _react.useCallback)(function () {
    // Don't do anything if the overlay is already open
    if (internalVisibility) {
      return;
    }

    setInternalVisibility(true);
  }, [internalVisibility]);
  var handleClose = (0, _react.useCallback)(function () {
    // Don't do anything if the overlay is already closed
    if (!internalVisibility) {
      return;
    }

    setInternalVisibility(false);
  }, [internalVisibility]);
  var handleToggle = (0, _react.useCallback)(function () {
    var willBeOpen = !internalVisibility;

    if (willBeOpen) {
      handleOpen();
    } else {
      handleClose();
    }
  }, [internalVisibility, handleOpen, handleClose]); // Provide a portal component so that we can grab its reference
  // to check if overlay needs to be closed if the user clicks outside of it.

  var wrapWithPortal = (0, _react.useCallback)(function (children) {
    if (!portalNode) {
      return null;
    }

    portalRef.current = /*#__PURE__*/(0, _reactDom.createPortal)(children, portalNode);
    return portalRef.current;
  }, [portalNode]);
  (0, _react.useEffect)(function () {
    computeBoundingBox();
  }, [internalVisibility, visible, computeBoundingBox]);
  (0, _react.useEffect)(function () {
    if (typeof visible !== 'undefined') {
      setInternalVisibility(visible);
    }
  }, [visible]);
  (0, _react.useEffect)(function () {
    onVisibilityChange == null ? void 0 : onVisibilityChange(internalVisibility);
  }, [internalVisibility, onVisibilityChange]);
  var fireEvent = (0, _react.useCallback)(function (type, event) {
    var _element$props$type, _element$props;

    (_element$props$type = (_element$props = element.props)[type]) == null ? void 0 : _element$props$type.call(_element$props, event);
  }, [element]);
  var onMouseEnter = (0, _react.useMemo)(function () {
    return (0, _lodashEs.debounce)(function (event) {
      fireEvent('onMouseEnter', event);
      handleOpen();
    }, mouseEnterDelay);
  }, [handleOpen, mouseEnterDelay, fireEvent]);
  var onMouseLeave = (0, _react.useMemo)(function () {
    return (0, _lodashEs.debounce)(function (event) {
      fireEvent('onMouseLeave', event); // Cancel the mouseEnter if it's enter event is delayed

      onMouseEnter.cancel();
      handleClose();
    }, mouseLeaveDelay);
  }, [handleClose, mouseLeaveDelay, fireEvent, onMouseEnter]);
  var onClick = (0, _react.useCallback)(function (event) {
    fireEvent('onClick', event);
    handleToggle();
  }, [handleToggle, fireEvent]);
  (0, _useCloseOnScroll.useCloseOnScroll)({
    container: body,
    node: portalNode,
    onClose: handleClose
  });
  (0, _useCloseOnClick.useCloseOnClick)({
    container: body,
    triggerNode: triggerRef.current,
    node: portalNode,
    closeOnInsideClick: closeOnInsideClick,
    onClose: handleClose
  });
  (0, _useCloseOnResize.useCloseOnResize)({
    node: portalNode,
    onClose: handleClose
  });
  var eventProps = (0, _react.useMemo)(function () {
    switch (trigger) {
      case 'click':
        return {
          onClick: onClick
        };

      case 'hover':
        return {
          onMouseEnter: onMouseEnter,
          onMouseLeave: onMouseLeave
        };

      default:
        return {};
    }
  }, [trigger, onMouseEnter, onMouseLeave, onClick]);

  var el = /*#__PURE__*/_react["default"].cloneElement(element, _extends({
    key: 'element-trigger',
    ref: triggerRef
  }, eventProps));

  var props = {
    isVisible: internalVisibility,
    containerBoundingBox: containerBoundingBox,
    close: handleClose,
    cancelClose: onMouseLeave.cancel,
    portal: wrapWithPortal
  };
  return [el, props];
};

exports.useTrigger = useTrigger;
{"ast":null,"code":"import React, { useCallback, useLayoutEffect, useRef, useState } from 'react';\nimport { getBoundingClientRect } from '../../utils/dom';\nimport { Box } from '../Box';\nimport { OPPOSITE_POSITION, OPPOSITE_ANCHOR } from './constants';\nimport { computePlacement, hasOverflowedHorizontally, hasOverflowedVertically } from './utils';\n/**\n * BoundaryAlignment simply renders its children, which represent\n * the main content.\n *\n * The overlay sets the positionning and basic styling.\n */\n\nexport var BoundaryAlignment = function BoundaryAlignment(_ref) {\n  var containerBoundingBox = _ref.containerBoundingBox,\n      fluid = _ref.fluid,\n      _ref$position = _ref.position,\n      position = _ref$position === void 0 ? 'bottom' : _ref$position,\n      _ref$anchor = _ref.anchor,\n      anchor = _ref$anchor === void 0 ? 'start' : _ref$anchor,\n      _ref$boundaryElement = _ref.boundaryElement,\n      boundaryElement = _ref$boundaryElement === void 0 ? window : _ref$boundaryElement,\n      onComputePlacement = _ref.onComputePlacement,\n      offset = _ref.offset,\n      onClick = _ref.onClick,\n      onMouseEnter = _ref.onMouseEnter,\n      onMouseLeave = _ref.onMouseLeave,\n      children = _ref.children;\n  var overlayRef = useRef(null);\n\n  var _useState = useState(),\n      positionState = _useState[0],\n      setPositionState = _useState[1];\n\n  var _useState2 = useState({\n    width: 0,\n    height: 0\n  }),\n      childrenDimensions = _useState2[0],\n      setChildrenDimensions = _useState2[1];\n\n  var getOverlayDimensions = useCallback(function () {\n    var _getBoundingClientRec = getBoundingClientRect(overlayRef.current),\n        width = _getBoundingClientRec.width,\n        height = _getBoundingClientRec.height;\n\n    return {\n      width: width,\n      height: height\n    };\n  }, []);\n  var computeOverlayStyle = useCallback(function () {\n    // Don't show the element until its position is being calculated.\n    if (!positionState) {\n      return {\n        opacity: 0\n      };\n    }\n\n    var top = positionState.top,\n        left = positionState.left; // Set overlay width to container's width\n\n    var width = fluid ? containerBoundingBox.width : undefined;\n    return {\n      top: top,\n      left: left,\n      width: width\n    };\n  }, [positionState, containerBoundingBox, fluid]);\n  var getOverlayPlacement = useCallback(function () {\n    var _getOverlayDimensions = getOverlayDimensions(),\n        width = _getOverlayDimensions.width,\n        height = _getOverlayDimensions.height; // By default we set the position overlay to the bottom/left\n    // and then we compute its placement depending on the props provided by the parent\n\n\n    return computePlacement({\n      top: containerBoundingBox.bottom,\n      left: containerBoundingBox.left,\n      width: width,\n      height: height\n    }, {\n      position: position,\n      anchor: anchor,\n      initialPosition: position,\n      initialAnchor: anchor,\n      containerBoundingBox: containerBoundingBox\n    });\n  }, [getOverlayDimensions, containerBoundingBox, position, anchor]);\n  var computeOverlayPlacement = useCallback(function () {\n    var initialPlacement = getOverlayPlacement();\n    var oppositePosition = OPPOSITE_POSITION[position];\n    var oppositeAnchor = OPPOSITE_ANCHOR[anchor];\n    var nextPosition = position;\n    var nextAnchor = anchor;\n\n    if (hasOverflowedHorizontally(initialPlacement, boundaryElement)) {\n      if (nextPosition === 'left' || nextPosition === 'right') {\n        nextPosition = oppositePosition;\n      } else if (nextAnchor === 'start' || nextAnchor === 'end') {\n        nextAnchor = oppositeAnchor;\n      }\n    }\n\n    if (hasOverflowedVertically(initialPlacement, boundaryElement)) {\n      if (nextPosition === 'top' || nextPosition === 'bottom') {\n        nextPosition = oppositePosition;\n      } else if (nextAnchor === 'start' || nextAnchor === 'end') {\n        nextAnchor = oppositeAnchor;\n      }\n    } // Compute the new placement depending on the new position and direction\n\n\n    var _computePlacement = computePlacement(initialPlacement, {\n      initialPosition: position,\n      position: nextPosition,\n      initialAnchor: anchor,\n      anchor: nextAnchor,\n      containerBoundingBox: containerBoundingBox,\n      offset: offset\n    }),\n        top = _computePlacement.top,\n        left = _computePlacement.left;\n\n    onComputePlacement == null ? void 0 : onComputePlacement({\n      position: nextPosition,\n      anchor: nextAnchor\n    });\n    setPositionState({\n      top: top,\n      left: left\n    });\n  }, [getOverlayPlacement, containerBoundingBox, position, anchor, onComputePlacement, offset, boundaryElement]);\n  useLayoutEffect(function () {\n    computeOverlayPlacement();\n  }, [computeOverlayPlacement]);\n  useLayoutEffect(function () {\n    var _getOverlayDimensions2 = getOverlayDimensions(),\n        width = _getOverlayDimensions2.width,\n        height = _getOverlayDimensions2.height;\n\n    var isWidthEqual = width === childrenDimensions.width;\n    var isHeightEqual = height === childrenDimensions.height; // Recompute the placement of the overlay if the children's width or height has changed\n\n    if (!isHeightEqual || !isWidthEqual) {\n      setChildrenDimensions({\n        width: width,\n        height: height\n      });\n      computeOverlayPlacement();\n    }\n  }, [getOverlayDimensions, childrenDimensions, computeOverlayPlacement]);\n  return /*#__PURE__*/React.createElement(Box, {\n    \"data-test\": \"boundary-alignment\",\n    position: \"fixed\",\n    zIndex: 1010,\n    onClick: onClick,\n    onMouseEnter: onMouseEnter,\n    onMouseLeave: onMouseLeave,\n    style: computeOverlayStyle(),\n    ref: overlayRef\n  }, children);\n};","map":{"version":3,"sources":["/Users/dinnosivagnanam/Development/Aircall-FrontEnd/node_modules/@aircall/tractor/es/components/BoundaryAlignment/BoundaryAlignment.js"],"names":["React","useCallback","useLayoutEffect","useRef","useState","getBoundingClientRect","Box","OPPOSITE_POSITION","OPPOSITE_ANCHOR","computePlacement","hasOverflowedHorizontally","hasOverflowedVertically","BoundaryAlignment","_ref","containerBoundingBox","fluid","_ref$position","position","_ref$anchor","anchor","_ref$boundaryElement","boundaryElement","window","onComputePlacement","offset","onClick","onMouseEnter","onMouseLeave","children","overlayRef","_useState","positionState","setPositionState","_useState2","width","height","childrenDimensions","setChildrenDimensions","getOverlayDimensions","_getBoundingClientRec","current","computeOverlayStyle","opacity","top","left","undefined","getOverlayPlacement","_getOverlayDimensions","bottom","initialPosition","initialAnchor","computeOverlayPlacement","initialPlacement","oppositePosition","oppositeAnchor","nextPosition","nextAnchor","_computePlacement","_getOverlayDimensions2","isWidthEqual","isHeightEqual","createElement","zIndex","style","ref"],"mappings":"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","sourcesContent":["import React, { useCallback, useLayoutEffect, useRef, useState } from 'react';\nimport { getBoundingClientRect } from '../../utils/dom';\nimport { Box } from '../Box';\nimport { OPPOSITE_POSITION, OPPOSITE_ANCHOR } from './constants';\nimport { computePlacement, hasOverflowedHorizontally, hasOverflowedVertically } from './utils';\n/**\n * BoundaryAlignment simply renders its children, which represent\n * the main content.\n *\n * The overlay sets the positionning and basic styling.\n */\n\nexport var BoundaryAlignment = function BoundaryAlignment(_ref) {\n  var containerBoundingBox = _ref.containerBoundingBox,\n      fluid = _ref.fluid,\n      _ref$position = _ref.position,\n      position = _ref$position === void 0 ? 'bottom' : _ref$position,\n      _ref$anchor = _ref.anchor,\n      anchor = _ref$anchor === void 0 ? 'start' : _ref$anchor,\n      _ref$boundaryElement = _ref.boundaryElement,\n      boundaryElement = _ref$boundaryElement === void 0 ? window : _ref$boundaryElement,\n      onComputePlacement = _ref.onComputePlacement,\n      offset = _ref.offset,\n      onClick = _ref.onClick,\n      onMouseEnter = _ref.onMouseEnter,\n      onMouseLeave = _ref.onMouseLeave,\n      children = _ref.children;\n  var overlayRef = useRef(null);\n\n  var _useState = useState(),\n      positionState = _useState[0],\n      setPositionState = _useState[1];\n\n  var _useState2 = useState({\n    width: 0,\n    height: 0\n  }),\n      childrenDimensions = _useState2[0],\n      setChildrenDimensions = _useState2[1];\n\n  var getOverlayDimensions = useCallback(function () {\n    var _getBoundingClientRec = getBoundingClientRect(overlayRef.current),\n        width = _getBoundingClientRec.width,\n        height = _getBoundingClientRec.height;\n\n    return {\n      width: width,\n      height: height\n    };\n  }, []);\n  var computeOverlayStyle = useCallback(function () {\n    // Don't show the element until its position is being calculated.\n    if (!positionState) {\n      return {\n        opacity: 0\n      };\n    }\n\n    var top = positionState.top,\n        left = positionState.left; // Set overlay width to container's width\n\n    var width = fluid ? containerBoundingBox.width : undefined;\n    return {\n      top: top,\n      left: left,\n      width: width\n    };\n  }, [positionState, containerBoundingBox, fluid]);\n  var getOverlayPlacement = useCallback(function () {\n    var _getOverlayDimensions = getOverlayDimensions(),\n        width = _getOverlayDimensions.width,\n        height = _getOverlayDimensions.height; // By default we set the position overlay to the bottom/left\n    // and then we compute its placement depending on the props provided by the parent\n\n\n    return computePlacement({\n      top: containerBoundingBox.bottom,\n      left: containerBoundingBox.left,\n      width: width,\n      height: height\n    }, {\n      position: position,\n      anchor: anchor,\n      initialPosition: position,\n      initialAnchor: anchor,\n      containerBoundingBox: containerBoundingBox\n    });\n  }, [getOverlayDimensions, containerBoundingBox, position, anchor]);\n  var computeOverlayPlacement = useCallback(function () {\n    var initialPlacement = getOverlayPlacement();\n    var oppositePosition = OPPOSITE_POSITION[position];\n    var oppositeAnchor = OPPOSITE_ANCHOR[anchor];\n    var nextPosition = position;\n    var nextAnchor = anchor;\n\n    if (hasOverflowedHorizontally(initialPlacement, boundaryElement)) {\n      if (nextPosition === 'left' || nextPosition === 'right') {\n        nextPosition = oppositePosition;\n      } else if (nextAnchor === 'start' || nextAnchor === 'end') {\n        nextAnchor = oppositeAnchor;\n      }\n    }\n\n    if (hasOverflowedVertically(initialPlacement, boundaryElement)) {\n      if (nextPosition === 'top' || nextPosition === 'bottom') {\n        nextPosition = oppositePosition;\n      } else if (nextAnchor === 'start' || nextAnchor === 'end') {\n        nextAnchor = oppositeAnchor;\n      }\n    } // Compute the new placement depending on the new position and direction\n\n\n    var _computePlacement = computePlacement(initialPlacement, {\n      initialPosition: position,\n      position: nextPosition,\n      initialAnchor: anchor,\n      anchor: nextAnchor,\n      containerBoundingBox: containerBoundingBox,\n      offset: offset\n    }),\n        top = _computePlacement.top,\n        left = _computePlacement.left;\n\n    onComputePlacement == null ? void 0 : onComputePlacement({\n      position: nextPosition,\n      anchor: nextAnchor\n    });\n    setPositionState({\n      top: top,\n      left: left\n    });\n  }, [getOverlayPlacement, containerBoundingBox, position, anchor, onComputePlacement, offset, boundaryElement]);\n  useLayoutEffect(function () {\n    computeOverlayPlacement();\n  }, [computeOverlayPlacement]);\n  useLayoutEffect(function () {\n    var _getOverlayDimensions2 = getOverlayDimensions(),\n        width = _getOverlayDimensions2.width,\n        height = _getOverlayDimensions2.height;\n\n    var isWidthEqual = width === childrenDimensions.width;\n    var isHeightEqual = height === childrenDimensions.height; // Recompute the placement of the overlay if the children's width or height has changed\n\n    if (!isHeightEqual || !isWidthEqual) {\n      setChildrenDimensions({\n        width: width,\n        height: height\n      });\n      computeOverlayPlacement();\n    }\n  }, [getOverlayDimensions, childrenDimensions, computeOverlayPlacement]);\n  return /*#__PURE__*/React.createElement(Box, {\n    \"data-test\": \"boundary-alignment\",\n    position: \"fixed\",\n    zIndex: 1010,\n    onClick: onClick,\n    onMouseEnter: onMouseEnter,\n    onMouseLeave: onMouseLeave,\n    style: computeOverlayStyle(),\n    ref: overlayRef\n  }, children);\n};"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\n/**\n * It computes the top position of the BoundaryAlignment based on the BoundaryAlignment and parent dimensions\n */\n\nexport var computeTop = function computeTop(_ref) {\n  var position = _ref.position,\n      anchor = _ref.anchor,\n      overlayDimensions = _ref.overlayDimensions,\n      containerBoundingBox = _ref.containerBoundingBox;\n\n  if (position === 'top') {\n    return containerBoundingBox.top - overlayDimensions.height;\n  }\n\n  if (position === 'bottom') {\n    return containerBoundingBox.bottom;\n  }\n\n  if (position === 'right' || position === 'left') {\n    if (anchor === 'end') {\n      return containerBoundingBox.bottom - overlayDimensions.height;\n    }\n\n    if (anchor === 'start') {\n      return containerBoundingBox.top;\n    }\n\n    if (anchor === 'center') {\n      return containerBoundingBox.top + containerBoundingBox.height / 2 - overlayDimensions.height / 2;\n    }\n  }\n\n  return 0;\n};\n/**\n * It computes the left position of the BoundaryAlignment based on the BoundaryAlignment and parent dimensions\n */\n\nexport var computeLeft = function computeLeft(_ref2) {\n  var position = _ref2.position,\n      anchor = _ref2.anchor,\n      overlayDimensions = _ref2.overlayDimensions,\n      containerBoundingBox = _ref2.containerBoundingBox;\n\n  if (position === 'right') {\n    return containerBoundingBox.right;\n  }\n\n  if (position === 'left') {\n    return containerBoundingBox.left - overlayDimensions.width;\n  }\n\n  if (position === 'top' || position === 'bottom') {\n    if (anchor === 'center') {\n      return containerBoundingBox.left - overlayDimensions.width / 2 + containerBoundingBox.width / 2;\n    }\n\n    if (anchor === 'start') {\n      return containerBoundingBox.left;\n    }\n\n    if (anchor === 'end') {\n      return containerBoundingBox.right - overlayDimensions.width;\n    }\n  }\n\n  return 0;\n};\n/**\n * Add extra offset to the BoundaryAlignment if provided\n */\n\nexport var adjustPlacement = function adjustPlacement(placement, props) {\n  var _offset$top, _offset$left;\n\n  var initialPosition = props.initialPosition,\n      position = props.position,\n      initialAnchor = props.initialAnchor,\n      anchor = props.anchor,\n      offset = props.offset;\n  var topOffset = (_offset$top = offset == null ? void 0 : offset.top) != null ? _offset$top : 0;\n  var leftOffset = (_offset$left = offset == null ? void 0 : offset.left) != null ? _offset$left : 0;\n  var hasPositionChanged = initialPosition !== position;\n  var hasAnchorChanged = initialAnchor !== anchor; // coefficient determines if we need to subtract or add the offset to the top/left positions\n\n  var topCoefficient = hasPositionChanged && ['top', 'bottom'].includes(position) || hasAnchorChanged && ['start', 'end'].includes(anchor) ? -1 : 1;\n  var leftCoefficient = hasPositionChanged && ['left', 'right'].includes(position) || hasAnchorChanged && ['start', 'end'].includes(anchor) ? -1 : 1;\n  return _extends({}, placement, {\n    top: placement.top + topCoefficient * topOffset,\n    left: placement.left + leftCoefficient * leftOffset\n  });\n};\nexport var getElementBoundaries = function getElementBoundaries(boundaryElement) {\n  if (boundaryElement instanceof HTMLElement) {\n    var _boundaryElement$getB = boundaryElement.getBoundingClientRect(),\n        right = _boundaryElement$getB.right,\n        bottom = _boundaryElement$getB.bottom,\n        top = _boundaryElement$getB.top,\n        left = _boundaryElement$getB.left;\n\n    return {\n      rightBoundary: right,\n      bottomBoundary: bottom,\n      topBoundary: top,\n      leftBoundary: left\n    };\n  }\n\n  return {\n    rightBoundary: boundaryElement.innerWidth,\n    bottomBoundary: boundaryElement.innerHeight,\n    topBoundary: 0,\n    leftBoundary: 0\n  };\n};\n/**\n * Checks if the BoundaryAlignment is popping out horizontally of the parent container\n */\n\nexport function hasOverflowedHorizontally(placement, boundaryElement) {\n  var _getElementBoundaries = getElementBoundaries(boundaryElement),\n      rightBoundary = _getElementBoundaries.rightBoundary,\n      leftBoundary = _getElementBoundaries.leftBoundary;\n\n  return placement.left + placement.width > rightBoundary || placement.left < leftBoundary;\n}\n/**\n * Checks if the BoundaryAlignment is popping out vertically of the parent container\n */\n\nexport function hasOverflowedVertically(placement, boundaryElement) {\n  var _getElementBoundaries2 = getElementBoundaries(boundaryElement),\n      bottomBoundary = _getElementBoundaries2.bottomBoundary,\n      topBoundary = _getElementBoundaries2.topBoundary;\n\n  return placement.top + placement.height > bottomBoundary || placement.top < topBoundary;\n}\nexport var computePlacement = function computePlacement(overlayDimensions, props) {\n  var containerBoundingBox = props.containerBoundingBox;\n  var top = computeTop({\n    position: props.position,\n    anchor: props.anchor,\n    overlayDimensions: overlayDimensions,\n    containerBoundingBox: containerBoundingBox\n  });\n  var left = computeLeft({\n    position: props.position,\n    anchor: props.anchor,\n    overlayDimensions: overlayDimensions,\n    containerBoundingBox: containerBoundingBox\n  });\n  return adjustPlacement({\n    left: left,\n    top: top,\n    width: overlayDimensions.width,\n    height: overlayDimensions.height\n  }, props);\n};","map":{"version":3,"sources":["/Users/dinnosivagnanam/Development/Aircall-FrontEnd/node_modules/@aircall/tractor/es/components/BoundaryAlignment/utils.js"],"names":["_extends","computeTop","_ref","position","anchor","overlayDimensions","containerBoundingBox","top","height","bottom","computeLeft","_ref2","right","left","width","adjustPlacement","placement","props","_offset$top","_offset$left","initialPosition","initialAnchor","offset","topOffset","leftOffset","hasPositionChanged","hasAnchorChanged","topCoefficient","includes","leftCoefficient","getElementBoundaries","boundaryElement","HTMLElement","_boundaryElement$getB","getBoundingClientRect","rightBoundary","bottomBoundary","topBoundary","leftBoundary","innerWidth","innerHeight","hasOverflowedHorizontally","_getElementBoundaries","hasOverflowedVertically","_getElementBoundaries2","computePlacement"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\n\n/**\n * It computes the top position of the BoundaryAlignment based on the BoundaryAlignment and parent dimensions\n */\nexport var computeTop = function computeTop(_ref) {\n  var position = _ref.position,\n      anchor = _ref.anchor,\n      overlayDimensions = _ref.overlayDimensions,\n      containerBoundingBox = _ref.containerBoundingBox;\n\n  if (position === 'top') {\n    return containerBoundingBox.top - overlayDimensions.height;\n  }\n\n  if (position === 'bottom') {\n    return containerBoundingBox.bottom;\n  }\n\n  if (position === 'right' || position === 'left') {\n    if (anchor === 'end') {\n      return containerBoundingBox.bottom - overlayDimensions.height;\n    }\n\n    if (anchor === 'start') {\n      return containerBoundingBox.top;\n    }\n\n    if (anchor === 'center') {\n      return containerBoundingBox.top + containerBoundingBox.height / 2 - overlayDimensions.height / 2;\n    }\n  }\n\n  return 0;\n};\n/**\n * It computes the left position of the BoundaryAlignment based on the BoundaryAlignment and parent dimensions\n */\n\nexport var computeLeft = function computeLeft(_ref2) {\n  var position = _ref2.position,\n      anchor = _ref2.anchor,\n      overlayDimensions = _ref2.overlayDimensions,\n      containerBoundingBox = _ref2.containerBoundingBox;\n\n  if (position === 'right') {\n    return containerBoundingBox.right;\n  }\n\n  if (position === 'left') {\n    return containerBoundingBox.left - overlayDimensions.width;\n  }\n\n  if (position === 'top' || position === 'bottom') {\n    if (anchor === 'center') {\n      return containerBoundingBox.left - overlayDimensions.width / 2 + containerBoundingBox.width / 2;\n    }\n\n    if (anchor === 'start') {\n      return containerBoundingBox.left;\n    }\n\n    if (anchor === 'end') {\n      return containerBoundingBox.right - overlayDimensions.width;\n    }\n  }\n\n  return 0;\n};\n/**\n * Add extra offset to the BoundaryAlignment if provided\n */\n\nexport var adjustPlacement = function adjustPlacement(placement, props) {\n  var _offset$top, _offset$left;\n\n  var initialPosition = props.initialPosition,\n      position = props.position,\n      initialAnchor = props.initialAnchor,\n      anchor = props.anchor,\n      offset = props.offset;\n  var topOffset = (_offset$top = offset == null ? void 0 : offset.top) != null ? _offset$top : 0;\n  var leftOffset = (_offset$left = offset == null ? void 0 : offset.left) != null ? _offset$left : 0;\n  var hasPositionChanged = initialPosition !== position;\n  var hasAnchorChanged = initialAnchor !== anchor; // coefficient determines if we need to subtract or add the offset to the top/left positions\n\n  var topCoefficient = hasPositionChanged && ['top', 'bottom'].includes(position) || hasAnchorChanged && ['start', 'end'].includes(anchor) ? -1 : 1;\n  var leftCoefficient = hasPositionChanged && ['left', 'right'].includes(position) || hasAnchorChanged && ['start', 'end'].includes(anchor) ? -1 : 1;\n  return _extends({}, placement, {\n    top: placement.top + topCoefficient * topOffset,\n    left: placement.left + leftCoefficient * leftOffset\n  });\n};\nexport var getElementBoundaries = function getElementBoundaries(boundaryElement) {\n  if (boundaryElement instanceof HTMLElement) {\n    var _boundaryElement$getB = boundaryElement.getBoundingClientRect(),\n        right = _boundaryElement$getB.right,\n        bottom = _boundaryElement$getB.bottom,\n        top = _boundaryElement$getB.top,\n        left = _boundaryElement$getB.left;\n\n    return {\n      rightBoundary: right,\n      bottomBoundary: bottom,\n      topBoundary: top,\n      leftBoundary: left\n    };\n  }\n\n  return {\n    rightBoundary: boundaryElement.innerWidth,\n    bottomBoundary: boundaryElement.innerHeight,\n    topBoundary: 0,\n    leftBoundary: 0\n  };\n};\n/**\n * Checks if the BoundaryAlignment is popping out horizontally of the parent container\n */\n\nexport function hasOverflowedHorizontally(placement, boundaryElement) {\n  var _getElementBoundaries = getElementBoundaries(boundaryElement),\n      rightBoundary = _getElementBoundaries.rightBoundary,\n      leftBoundary = _getElementBoundaries.leftBoundary;\n\n  return placement.left + placement.width > rightBoundary || placement.left < leftBoundary;\n}\n/**\n * Checks if the BoundaryAlignment is popping out vertically of the parent container\n */\n\nexport function hasOverflowedVertically(placement, boundaryElement) {\n  var _getElementBoundaries2 = getElementBoundaries(boundaryElement),\n      bottomBoundary = _getElementBoundaries2.bottomBoundary,\n      topBoundary = _getElementBoundaries2.topBoundary;\n\n  return placement.top + placement.height > bottomBoundary || placement.top < topBoundary;\n}\nexport var computePlacement = function computePlacement(overlayDimensions, props) {\n  var containerBoundingBox = props.containerBoundingBox;\n  var top = computeTop({\n    position: props.position,\n    anchor: props.anchor,\n    overlayDimensions: overlayDimensions,\n    containerBoundingBox: containerBoundingBox\n  });\n  var left = computeLeft({\n    position: props.position,\n    anchor: props.anchor,\n    overlayDimensions: overlayDimensions,\n    containerBoundingBox: containerBoundingBox\n  });\n  return adjustPlacement({\n    left: left,\n    top: top,\n    width: overlayDimensions.width,\n    height: overlayDimensions.height\n  }, props);\n};"]},"metadata":{},"sourceType":"module"}